import BigNumber from 'bignumber.js';
import { PortfolioId as MeshPortfolioId } from 'polymesh-types/types';

import {
  Context,
  Entity,
  Identity,
  modifyInstructionAuthorization,
  SecurityToken,
  TransactionQueue,
  Venue,
} from '~/internal';
import { InstructionAuthorizationOperation } from '~/types/internal';
import {
  balanceToBigNumber,
  identityIdToString,
  meshAuthorizationStatusToAuthorizationStatus,
  meshInstructionStatusToInstructionStatus,
  momentToDate,
  numberToU64,
  portfolioIdToPortfolio,
  tickerToString,
  u32ToBigNumber,
  u64ToBigNumber,
} from '~/utils';

import { InstructionAuthorization, InstructionDetails, InstructionType, Leg } from './types';

export interface UniqueIdentifiers {
  id: BigNumber;
}

/**
 * Represents a settlement Instruction to be executed on a certain Venue
 */
export class Instruction extends Entity<UniqueIdentifiers> {
  /**
   * @hidden
   * Check if a value is of type [[UniqueIdentifiers]]
   */
  public static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers {
    const { id } = identifier as UniqueIdentifiers;

    return id instanceof BigNumber;
  }

  /**
   * Identifier number of the venue
   */
  public id: BigNumber;

  /**
   * @hidden
   */
  public constructor(identifiers: UniqueIdentifiers, context: Context) {
    super(identifiers, context);

    const { id } = identifiers;

    this.id = id;
  }

  /**
   * Retrieve information specific to this Instruction
   */
  public async details(): Promise<InstructionDetails> {
    const {
      context: {
        polymeshApi: {
          query: { settlement },
        },
      },
      id,
      context,
    } = this;

    const {
      status,
      created_at: createdAt,
      valid_from: validFrom,
      settlement_type: type,
      venue_id: venueId,
    } = await settlement.instructionDetails(numberToU64(id, context));

    const details = {
      status: meshInstructionStatusToInstructionStatus(status),
      createdAt: momentToDate(createdAt.unwrap()),
      validFrom: validFrom.isSome ? momentToDate(validFrom.unwrap()) : null,
      venue: new Venue({ id: u64ToBigNumber(venueId) }, context),
    };

    if (type.isSettleOnAuthorization) {
      return {
        ...details,
        type: InstructionType.SettleOnAuthorization,
      };
    }

    return {
      ...details,
      type: InstructionType.SettleOnBlock,
      endBlock: u32ToBigNumber(type.asSettleOnBlock),
    };
  }

  /**
   * Retrieve every authorization generated by this Instruction (status and authorizing Identity)
   */
  public async getAuthorizations(): Promise<InstructionAuthorization[]> {
    const {
      context: {
        polymeshApi: {
          query: { settlement },
        },
      },
      id,
      context,
    } = this;

    const entries = await settlement.authsReceived.entries(numberToU64(id, context));

    const instructionAuthorizations: InstructionAuthorization[] = [];

    entries.forEach(([key, meshAuthorizationStatus]) => {
      const { did } = key.args[1] as MeshPortfolioId;
      instructionAuthorizations.push({
        identity: new Identity({ did: identityIdToString(did) }, context),
        authorizationStatus: meshAuthorizationStatusToAuthorizationStatus(meshAuthorizationStatus),
      });
    });

    return instructionAuthorizations;
  }

  /**
   * Retrieve all legs of this Instruction
   */
  public async getLegs(): Promise<Leg[]> {
    const {
      context: {
        polymeshApi: {
          query: { settlement },
        },
      },
      id,
      context,
    } = this;

    const legs = await settlement.instructionLegs.entries(numberToU64(id, context));

    return legs.map(([, leg]) => {
      const { from, to, amount, asset } = leg;

      const ticker = tickerToString(asset);
      const fromPortfolio = portfolioIdToPortfolio(from, context);
      const toPortfolio = portfolioIdToPortfolio(to, context);

      return {
        from: fromPortfolio,
        to: toPortfolio,
        amount: balanceToBigNumber(amount),
        token: new SecurityToken({ ticker }, context),
      };
    });
  }

  /**
   * Reject this instruction
   *
   * @note reject on `SettleOnAuthorization` will execute the settlement and it will fail immediately.
   * @note reject on `SettleOnBlock` behaves just like unauthorize
   */
  public reject(): Promise<TransactionQueue<Instruction>> {
    const { id, context } = this;
    return modifyInstructionAuthorization.prepare(
      { id, operation: InstructionAuthorizationOperation.Reject },
      context
    );
  }

  /**
   * Authorize this instruction
   */
  public authorize(): Promise<TransactionQueue<Instruction>> {
    const { id, context } = this;
    return modifyInstructionAuthorization.prepare(
      { id, operation: InstructionAuthorizationOperation.Authorize },
      context
    );
  }

  /**
   * Unauthorize this instruction
   */
  public unauthorize(): Promise<TransactionQueue<Instruction>> {
    const { id, context } = this;
    return modifyInstructionAuthorization.prepare(
      { id, operation: InstructionAuthorizationOperation.Unauthorize },
      context
    );
  }
}
